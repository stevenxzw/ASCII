

'use strict';

module.exports = function (grunt) {


    var ln = grunt.util.normalizelf('\n');

	var lithe = require('lithe');
	var fs = require('fs');
	var crypto = require('crypto');
	var path = require('path');
	var hfs = lithe.hfs;

	
	
	function getMd5(p){
		var str = fs.readFileSync(p,'utf-8');
		var md5um = crypto.createHash('md5');
		md5um.update(str);
		return md5um.digest('hex');
	}

	function _gcf(){
		this.database = path.join(process.cwd(),'./.gcf');
		if(!fs.existsSync(this.database)){
			hfs.writeFileSync(this.database,'{}','utf-8');
		}
	}

	_gcf.prototype = {
		constructor:_gcf,
		get:function(p,filter){
			var self = this,
				base = fs.readFileSync(this.database),
				changedList = [],
				files;
			base = JSON.parse(base);
			hfs.walk(p,function(lists,a){
				files = lists;
				files.forEach(function(filepath){
					var md5str = getMd5(filepath);
					if(!base[filepath] || (base[filepath] && base[filepath] !== md5str)) changedList.push(filepath);
					base[filepath] = md5str;
				});


				hfs.writeFileSync(self.database,JSON.stringify(base),'utf-8');
			},{
				filter:filter
			});

			return changedList;
		}
	};
	
	var fs = require( 'fs' ),
    stat = fs.stat;
	
	
    grunt.registerMultiTask('gcf', 'Compiled template files into JavaScript files', function (r) {
		console.log('in--gcf');
		var T = require('grunt').template.today("yyyy-mm-dd HH:MM");

		if(this.target === 'read'){//查看是否有修改过的文件
			console.log('read');
			console.log(this);
			console.log('-----------------');

			var gcf = new _gcf();

			var changed = gcf.get(this.data.src,function(item){

                if(item.match(/^node_modules|^\./)){
                    //console.log('return false');
                    return false;
                }
                return true;
            });

            console.log(changed); 

			if(changed.length){//有修改过的文件
				var _dst = this.data.dist,

					readable, writable;  
				    var options = this.options({
					  encoding: grunt.file.defaultEncoding,
					  // processContent/processContentExclude deprecated renamed to process/noProcess
					  processContent: false,
					  processContentExclude: [],
					  mode: false
					});

					var copyOptions = {
					  encoding: options.encoding,
					  process: options.process || options.processContent,
					  noProcess: options.noProcess || options.processContentExclude,
					};
				for(var i=0,l=changed.length;i<l;i++){
				
					
					(function(src){
							grunt.file.copy(src, _dst+src.split('\\')[1], copyOptions);
							return;
						//console.log('stat'+_dst);
						//src = './temp/qq.js';
								readable = fs.createReadStream( src );

								// 创建写入流

								writable = fs.createWriteStream( _dst+src.split('\\')[1]);  

								// 通过管道来传输流
								readable.pipe( writable );
								
								readable.on('end', function () {
								 console.log('copy end');
								});
								
								readable.on('error', function () {
								 console.log('copy error');
								});
						/*
						stat( './temp/qq.js', function( err, st ){
						console.log('in-stat');
							if( err ){

								throw err;

							}			 

							// 判断是否为文件

							if( st.isFile() ){
							console.log('in-isFile');
								// 创建读取流

								readable = fs.createReadStream( src );

								// 创建写入流

								writable = fs.createWriteStream( _dst );  

								// 通过管道来传输流
								console.log('in-pipe');
								readable.pipe( writable );

							}

							// 如果是目录则递归调用自身

							else if( st.isDirectory() ){

								exists( src, _dst, copy );

							}
							
						});
*/
					})(changed[i]);
				}
			
			}
		
		}else if(this.target === 'toEndCode'){//把代码再
			console.log('toEndCode');

		}
	
    });
	
	var exists = function( src, dst, callback ){
			//console.log('in-exists:'+fs.exists);
			fs.exists( dst, function( exists ){
//console.log('in-exists:');
				// 已存在
					
				if( exists ){
					console.log('exists');
					callback( src, dst );

				}

				// 不存在

				else{
					console.log('unexists');
					fs.mkdir( dst, function(){

						callback( src, dst );

					});

				}

			});

		};
	

    function endsWith(str, suffix) {
        var index = str.length - suffix.length;
        return index >= 0 && str.indexOf(suffix, index) == index;
    }
};
